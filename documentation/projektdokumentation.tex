\documentclass[twoside]{report}

% ------
% Umlaute
\usepackage{ifluatex,ifxetex}
\ifluatex
  \usepackage{fontspec}
\else
  \ifxetex
    \usepackage{fontspec}
  \else
    \usepackage{selinput}
    \SelectInputMappings{
      adieresis={ä},
      germandbls={ß},
    }
    \usepackage[T1]{fontenc}
    %\usepackage{textcomp}% optional
    %\usepackage{lmodern}
  \fi
\fi

% ------
% Paper auf Deutsch
\usepackage[ngerman]{babel}



% ------
% Page layout
\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry}
\usepackage[font=it]{caption}
\usepackage{paralist}
%\usepackage{multicol}


% ------
% Abstract
\usepackage{abstract}
	\renewcommand{\abstractnamefont}{\normalfont\bfseries}
	\renewcommand{\abstracttextfont}{\normalfont\small\itshape}


% ------
% Titling (section/subsection)
\usepackage{titlesec}
\renewcommand\thesection{\Roman{section}}
\titleformat{\section}[block]{\Large\scshape\bfseries}{\thesection.}{1em}{}
\setcounter{secnumdepth}{3}

% ------
% Tabellen über Seitenumbrüche hinweg
\usepackage{longtable}

% ------
% Header/footer
\usepackage{fancyhdr}
	\pagestyle{fancy}
	\fancyhead{}
	\fancyfoot{}
	\fancyhead[C]{Projektdokumentation $\bullet$ PROJEKTNAME $\bullet$ SS17$+$WS17/18}
	\fancyfoot[RO,LE]{}


% ------
% Clickable URLs (optional)
% \usepackage{hyperref}

% ------
% Literaturverweise mit Bibtex einbinden
\usepackage[authoryear,sectionbib,round]{natbib}

% ------
% Bilder laden
\usepackage[pdftex]{graphicx}

% ------
% Maketitle metadata
\title{\vspace{-5mm}%
	\fontsize{24pt}{10pt}\selectfont
	\textbf{Projektdokumentation}
	}	
\author{%
        % alle Autoren hier listen
        % 
	\large
	\textsc{Autor I -- E-Mail} \\[2mm]
	\textsc{Autor II -- E-Mail} \\[2mm]
	\normalsize	HTWK Leipzig 
	}
\date{}



%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}


% -------
% Titel und Abstract über beide Spalten
%\twocolumn[
%\begin{@twocolumnfalse}

\maketitle
\thispagestyle{fancy}

\tableofcontents

%%%%
%%%% Die Struktur des Dokuments bitte nicht aendern!!!
%%%%

\section{Anforderungsspezifikation}

\subsection{Initiale Kundenvorgaben}
{\small Autor: xxx}

Maecenas sed ultricies felis. Sed imperdiet dictum arcu a egestas.
In sapien ante, ultricies quis pellentesque ut, fringilla id sem. Proin justo libero, dapibus consequat auctor at, euismod et erat. Sed ut ipsum erat, iaculis vehicula lorem. Cras non dolor id libero blandit ornare. Pellentesque luctus fermentum eros ut posuere. Suspendisse rutrum suscipit massa sit amet molestie. Donec suscipit lacinia diam, eu posuere libero rutrum sed. Nam blandit lorem sit amet dolor vestibulum in lacinia purus varius. Ut tortor massa, rhoncus ut auctor eget, vestibulum ut justo.


\subsection{Produktvision}
{\small Autor: Alex Hofmann}
\\

\noindent Product Vision Board: \\
\begin{tabular}{|p{50mm}|p{50mm}|p{50mm}|}
  \hline
  \textbf{Target Group}                                                  & \textbf{Needs}                                                                                                                        & \textbf{Product}                                                                                                                                                                                                 \\
  \hline
  -Maschinenbau-Studenten \newline Maschinenbau-Profs \newline -Lehrende & Vgl. zu händisch: \newline einheitlicher, schneller \newline -plattformunabhängig \newline -Open Source \newline -Einfach zu bedienen & -Webanwendung \newline -Als Graph \newline $\rightarrow$ quasi als Baukasten \newline $\rightarrow$ Kantengewichtung, Bausteine wählbar \newline -Import/Export von Modellen \newline Normalisierung des Graphen \\
  \hline
\end{tabular}
\\

\noindent Die Webanwendung VarG ist entwickelt für Lehrende und Lernende aus dem Maschinenbau Bachelorstudiengang.
Diese erleichtert die einheitliche Erstellung, Bearbeitung, Optimierung sowie Im- bzw. Exportierung von sogenannten Variantenfolgegraphen. Darunter ist eine graphische Übersicht zu verstehen, die die möglichen Varianten eines Produktionsprozesses für ein Werkstück darstellt.



% Das hier ist ein Absatz, der die Grafik in Abbildung~\ref{fig:bild1} detailliert erläutert, erklärt und interpretiert.

% \begin{figure}[b]
%   \centering
%   \includegraphics[width=4.5cm]{bspbild1.png}
%   \caption{Beispiel für ein einspaltiges Bild}
%   \label{fig:bild1}
% \end{figure}


\subsection{Liste der funktionalen Anforderungen}

XXX

%
% soll der Inhalt dieser Subsection in einer separaten Datei
% (z.B. listefunktional.tex) liegen, dann kann dies mit dem
% folgenden Kommando geschehen.
%
% \input{listefunktional}

\subsection{Liste der nicht-funktionalen Anforderungen}
{\small Autor: xxx}

XXX

\subsection{Weitere Zuarbeiten zum Produktvisions-Workshop}

XXX

\subsubsection{Zuarbeit von Autor X}
XXX
\subsubsection{Zuarbeit von Autor Y}
XXX

\subsection{Liste der Kundengespräche mit Ergebnissen}
{\small Autor: xxx}

XXX



\section{Architektur und Entwurf}

\subsection{Zuarbeiten der Teammitglieder}

XXX

\subsection{Entscheidungen des Technologieworkshops}
{\small Autor: xxx}

XXX

\subsection{Überblick über Architektur}
{\small Autor: Linus Herterich}

VarG ist eine Web-App nach dem Client-Server Modell, wobei der Großteil der Berechnungen per JavaScript auf dem clientseitigen Browser
durchgeführt werden.
\\Serverseitig wird eine Datenbank (inkl API-Schnittstelle) zum persistenten speichern der erstellten Graphen angeboten.
\\
\\Die Architektur der Web-App basiert auf dem Javascript-Webframework ''Vue.js'', 
mit dem Webanwendungen nach dem MVVM Muster (Model View ViewModel) realisiert werden können. Die gesamte App ist nach logischen
Sites (Seiten, bei denen sich die URL ändert) und Components (wiederverwendbare, abgeschlossene Software-Schnipsel) aufgebaut.
Jede Vue Component (.vue Dateien) enthält ein HTML-Template (GUI), sowie Daten, mit denen das Template befüllt wird. Zudem werden
Funktionen definiert, die entweder zu bestimmten Laufzeitbedingungen der App oder durch Events und Trigger aufgerufen werden.
Die Kommunikation zwischen Components wird über Vererbungen zu Eltern-/ Kind-Components realisiert.
\\Die Web-App besteht im Entwicklungszustand aus vielen hunderten Dateien, welche vom Framework verwaltet werden. Sobald
die App in den Produktionsstatus wechselt, muss das Projekt kompiliert werden. Dies übernimmt ebenfalls das Framework, welches
hierfür Technologien wie ''WebPack'' einsetzt. So bleiben lediglich wenige HTML, CSS und JavaScript Dateien übrig, die anschließend
auf einem Web-Server (z.B. Apache) zur Verfügung gestellt werden müssen.
\\
\\Um die Darstellung einheitlich zu halten, haben wir die UI-Bibliothek ''vuetify'' genutzt. Diese hält sich an den Industriestandard
''Material Design'' von Google. Damit konnten wir alle unsere im Vorfeld erstellten Design-Konzepte umsetzen. Um an den ''vuetify'' Elementen
weitere optische Anpassungen vorzunehmen haben wir die CSS-Language-Extension ''less'' verwendet. Mit dieser war es möglich übersichtliche und
einheitliche Style-Vorgaben die Design-Komponenten anzuwenden. 
\\
\\Damit Alle Daten Component-Übergreifend auf einen gemeinsamen Datenstamm zugreifen können und die Daten auch nach einer Session persistent
gespeichert werden können, haben wir die vue.js-Erweiterung ''vuex'' eingesetzt. Diese bietet eine zentralisierte Speichermöglichkeit
für alle Daten, die übergreifend verwendet werden müssen (beispielsweise Log-In Daten oder der Zustand des Variantenfolgegraphen).
\\
\\Für die Darstellung des Graphen (Knoten + Kanten und deren Beschriftung) haben wir das JavaScript Framework ''cytoscape.js'' verwendet.
Das Framework hält alle Graph-Daten in einem JavaScript Objekt, auf das mit verschiedenen API-Funktionen zugegriffen werden kann.
Die Darstellung des Graphen wird über ein Canvas HTML Element realisiert, in welches cytoscape die angelegten Knoten und Kanten zeichnet.
Cytoscape.js bietet ebenfalls eine Hand voll Algorithmen zur analytischen Auswertung des Graphen. Da die Optimierung des Variantenfolgegraphen
allerdings zusätzlicher Bedingungen und Parametern unterliegt, wurde ein eigener Variantenfolgegraph-Optimierungsalgorithmus entwickelt.
\\
\\Bei der Wahl der serverseitigen Architektur haben wir eine REST-Konforme (Representational State Transfer)
Architektur eingesetzt, in dessen Mitte eine MySQL Datenbank zur Speicherung der cytoscape Objekte, sowie Authentifizierungsdaten
steht. Auf die Daten der Datenbank greift eine API-Schnittstelle zu, welche mit Node.js umgesetzt ist (weitere Details zur Schnittstelle:
siehe II.4 - Schnittstellen). Anfragen an die API werden mit dem ''axios'' Framework per ''Promise-based'' HTTP-Requests gestellt. Die HTTP-Requests
folgen einem klaren Schema, welches vom serverseitigen Node.js interpretiert und an die Datenbank weitergeleitet wird.
\\
\\Um die Web-App großflächig zu testen haben wir uns zum einen für das Framework ''cypress'' entschieden, welches Integrationstests anhand der
HTML-Elemente übernimmt. Cypress wertet aus, ob bestimmte Elemente unter bestimmten Bedingungen vorhanden sind, beziehungsweise spezielle 
Eigenschaften aufweisen. Die Cypress Tests haben wir auch erfolgreich an die ''CI / CD Pipeline'' von GitLab angeschlossen, sodass nach jedem
push die Tests durchlaufen (Stichwort: Regressionstest).
\\Zum anderen haben wir das Framework "jest" eingesetzt, mit dem einzelne Funktionen auf ihre Richtigkeit überprüft werden konnten. Vorallem
für die Optimierungsalgorithmen sind isolierte Tests nötig gewesen.
\\
\\Um eine Client-Server Architektur zu simulieren haben wir ''Docker'' eingesetzt. Dieses Tool erlaubt es virtuelle Maschinen zu erstellen,
welche untereinander kommunizieren können. Für Entwicklungszwecke haben wir einen Docker-Container für eine MySQL Datenbank und 
einen Node.js-Webserver (API Schnittstelle) erzeugt.


\subsection{Definierte Schnittstellen}
{\small Autor: xxx}

XXX

\subsection{Liste der Architekturentscheidungen}
{\small Autor: xxx}

XXX (bewusste und unbewusste Entscheidungen mit zeitlicher Einordnung)



\section{Prozess- und Implementationsvorgaben}

\subsection{Definition of Done}
{\small Autor: Tim Henning}
\\
Im Allgemeinen wurde in dem Projekt die Definition von "doneness"\ nicht all zu umfangreich 
gestaltet, da es für viele Teammitglieder eines der ersten Softwareprojekte war. So wurden als Defintion of Done folgende
Punkte für alle Userstories aufgestellt:
\begin{itemize}
  \item >50\% Testabdeckung
  \item Technische Kommentare im Code
  \item Einhaltung der festgelegten Code Konventionen
\end{itemize}
\\
Das Team hatte an sich zu den meisten Zeitpunkten eine klare Vorstellung was einen "fertigen Entwurf"\ kennzeichnet und wurde so auch in den Reviews untereinander kommuniziert. 
Dies wiederum führte zu einer klaren Transparenz im Team, was die Qualität des Produktes erhöhte und das Zusammenarbeiten erleichterte.
Größtenteils wurde sich
an die allgemeinen Akzeptanzkritieren gehalten und viele Backlog-Einträge als "done"\ erklärt. Zu fast jeder Komponente wurde 
getestet und zu den Methoden der einzelnen Komponenten wurden erklärende sinnvolle Codekommentare geschrieben. 
Außerdem wurde im Team umfangreich kommuniziert und die Kriterien angepasst, wenn die Fertigstellung einer Userstorie doch mal nicht gänzlich klar war.
So wurde es ermöglicht nach der Hälfte des Projektes, am Ende jedes Sprints einen fertigen Productionbuild dem Kunden zu liefern.
  


\subsection{Coding Style}
{\small Autor: xxx}

XXX

\subsection{Zu nutzende Werkzeuge}
{\small Autor: xxx}

XXX

\newpage

%%%%%%%%%%%%
%% Abschnitt mit den Sprints beginnt hier
%%%%%%%%%%%%

\section{Sprint 1}

\input{sprint1}

\newpage

\section{Sprint 2}

\input{sprint2}

\newpage

\section{Sprint 3}

%\input{sprint3}

\newpage

\section{Sprint 4}

\input{sprint4}

\newpage

%%%%%% weitere Sprints analog


\section{Dokumentation}

\subsection{Handbuch}
{\small Autor: xxx}

XXX

\subsection{Installationsanleitung}
{\small Autor: xxx}

XXX

\subsection{Software-Lizenz}
{\small Autor: xxx}

XXX


\section{Projektabschluss}

\subsection{Protokoll der Abnahme und Inbetriebnahme beim Kunden}
{\small Autor: xxx}

XXX

\subsection{Präsentation auf der Messe}
{\small Autor: xxx}

Poster, Bericht

\subsection{Abschließende Einschätzung durch Product-Owner}
{\small Autor: xxx}

XXX

\subsection{Abschließende Einschätzung durch Software-Architekt}
{\small Autor: xxx}

XXX

\subsection{Abschließende Einschätzung durch Team-Manager}
{\small Autor: xxx}

XXX

\end{document}
