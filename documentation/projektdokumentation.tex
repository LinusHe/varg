\documentclass[twoside]{report}

% ------
% Umlaute
\usepackage{ifluatex,ifxetex}
\ifluatex
  \usepackage{fontspec}
\else
  \ifxetex
    \usepackage{fontspec}
  \else
    \usepackage{selinput}
    \SelectInputMappings{
      adieresis={ä},
      germandbls={ß},
    }
    \usepackage[T1]{fontenc}
    %\usepackage{textcomp}% optional
    %\usepackage{lmodern}
  \fi
\fi

% ------
% Paper auf Deutsch
\usepackage[ngerman]{babel}



% ------
% Page layout
\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry}
\usepackage[font=it]{caption}
\usepackage{paralist}
%\usepackage{multicol}


% ------
% Abstract
\usepackage{abstract}
	\renewcommand{\abstractnamefont}{\normalfont\bfseries}
	\renewcommand{\abstracttextfont}{\normalfont\small\itshape}


% ------
% Titling (section/subsection)
\usepackage{titlesec}
\renewcommand\thesection{\Roman{section}}
\titleformat{\section}[block]{\Large\scshape\bfseries}{\thesection.}{1em}{}
\setcounter{secnumdepth}{3}

% ------
% Tabellen über Seitenumbrüche hinweg
\usepackage{longtable}

% ------
% Header/footer
\usepackage{fancyhdr}
	\pagestyle{fancy}
	\fancyhead{}
	\fancyfoot{}
	\fancyhead[C]{Projektdokumentation $\bullet$ PROJEKTNAME $\bullet$ SS17$+$WS17/18}
	\fancyfoot[RO,LE]{}


% ------
% Clickable URLs (optional)
% \usepackage{hyperref}

% ------
% Literaturverweise mit Bibtex einbinden
\usepackage[authoryear,sectionbib,round]{natbib}

% ------
% Bilder laden
\usepackage[pdftex]{graphicx}

% ------
% Maketitle metadata
\title{\vspace{-5mm}%
	\fontsize{24pt}{10pt}\selectfont
	\textbf{Projektdokumentation}
	}	
\author{%
        % alle Autoren hier listen
        % 
	\large
	\textsc{Autor I -- E-Mail} \\[2mm]
	\textsc{Autor II -- E-Mail} \\[2mm]
	\normalsize	HTWK Leipzig 
	}
\date{}



%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}


% -------
% Titel und Abstract über beide Spalten
%\twocolumn[
%\begin{@twocolumnfalse}

\maketitle
\thispagestyle{fancy}

\tableofcontents

%%%%
%%%% Die Struktur des Dokuments bitte nicht aendern!!!
%%%%

\section{Anforderungsspezifikation}

\subsection{Initiale Kundenvorgaben}
{\small Autor: xxx}

Maecenas sed ultricies felis. Sed imperdiet dictum arcu a egestas.
In sapien ante, ultricies quis pellentesque ut, fringilla id sem. Proin justo libero, dapibus consequat auctor at, euismod et erat. Sed ut ipsum erat, iaculis vehicula lorem. Cras non dolor id libero blandit ornare. Pellentesque luctus fermentum eros ut posuere. Suspendisse rutrum suscipit massa sit amet molestie. Donec suscipit lacinia diam, eu posuere libero rutrum sed. Nam blandit lorem sit amet dolor vestibulum in lacinia purus varius. Ut tortor massa, rhoncus ut auctor eget, vestibulum ut justo.


\subsection{Produktvision}
{\small Autor: Alex Hofmann}
\\

\noindent Product Vision Board: \\
\begin{tabular}{|p{50mm}|p{50mm}|p{50mm}|}
  \hline
  \textbf{Target Group}                                                  & \textbf{Needs}                                                                                                                        & \textbf{Product}                                                                                                                                                                                                 \\
  \hline
  -Maschinenbau-Studenten \newline Maschinenbau-Profs \newline -Lehrende & Vgl. zu händisch: \newline einheitlicher, schneller \newline -plattformunabhängig \newline -Open Source \newline -Einfach zu bedienen & -Webanwendung \newline -Als Graph \newline $\rightarrow$ quasi als Baukasten \newline $\rightarrow$ Kantengewichtung, Bausteine wählbar \newline -Import/Export von Modellen \newline Normalisierung des Graphen \\
  \hline
\end{tabular}
\\

\noindent Die Webanwendung VarG ist entwickelt für Lehrende und Lernende aus dem Maschinenbau Bachelorstudiengang.
Diese erleichtert die einheitliche Erstellung, Bearbeitung, Optimierung sowie Im- bzw. Exportierung von sogenannten Variantenfolgegraphen. Darunter ist eine graphische Übersicht zu verstehen, die die möglichen Varianten eines Produktionsprozesses für ein Werkstück darstellt.



% Das hier ist ein Absatz, der die Grafik in Abbildung~\ref{fig:bild1} detailliert erläutert, erklärt und interpretiert.

% \begin{figure}[b]
%   \centering
%   \includegraphics[width=4.5cm]{bspbild1.png}
%   \caption{Beispiel für ein einspaltiges Bild}
%   \label{fig:bild1}
% \end{figure}


\subsection{Liste der funktionalen Anforderungen}

XXX

%
% soll der Inhalt dieser Subsection in einer separaten Datei
% (z.B. listefunktional.tex) liegen, dann kann dies mit dem
% folgenden Kommando geschehen.
%
% \input{listefunktional}

\subsection{Liste der nicht-funktionalen Anforderungen}
{\small Autor: xxx}

XXX

\subsection{Weitere Zuarbeiten zum Produktvisions-Workshop}

XXX

\subsubsection{Zuarbeit von Autor X}
XXX
\subsubsection{Zuarbeit von Autor Y}
XXX

\subsection{Liste der Kundengespräche mit Ergebnissen}
{\small Autor: xxx}

XXX



\section{Architektur und Entwurf}

\subsection{Zuarbeiten der Teammitglieder}

XXX

\subsection{Entscheidungen des Technologieworkshops}
{\small Autor: xxx}

XXX

\subsection{Überblick über Architektur}
{\small Autor: Linus Herterich}

VarG ist eine Web-App nach dem Client-Server Modell, wobei der Großteil der Berechnungen per JavaScript auf dem clientseitigen Browser
durchgeführt werden.
\\Serverseitig wird eine Datenbank (inkl API-Schnittstelle) zum persistenten Speichern der erstellten Graphen angeboten.
\\
\\Die Architektur der Web-App basiert auf dem Javascript-Webframework ''Vue.js'', 
mit dem Webanwendungen nach dem MVVM Muster (Model View ViewModel) realisiert werden können. Die gesamte App ist nach logischen
Sites (Seiten, bei denen sich die URL ändert) und Components (wiederverwendbare, abgeschlossene Software-Schnipsel) aufgebaut.
Jede Vue Component (.vue Dateien) enthält ein HTML-Template (GUI), sowie Daten, mit denen das Template befüllt wird. Zudem werden
Funktionen definiert, die entweder zu bestimmten Laufzeitbedingungen der App oder durch Events und Trigger aufgerufen werden.
Die Kommunikation zwischen Components wird über Vererbungen zu Eltern-/ Kind-Components realisiert.
\\Die Web-App besteht im Entwicklungszustand aus vielen hunderten Dateien, welche vom Framework verwaltet werden. Sobald
die App in den Produktionsstatus wechselt, muss das Projekt kompiliert werden. Dies übernimmt ebenfalls das Framework, welches
hierfür Technologien wie ''WebPack'' einsetzt. So bleiben lediglich wenige HTML, CSS und JavaScript Dateien übrig, die anschließend
auf einem Web-Server (z.B. Apache) zur Verfügung gestellt werden müssen.
\\
\\Um die Darstellung einheitlich zu halten, haben wir die UI-Bibliothek ''vuetify'' genutzt. Diese hält sich an den Industriestandard
''Material Design'' von Google. Damit konnten wir alle unsere im Vorfeld erstellten Design-Konzepte umsetzen. Um an den ''vuetify'' Elementen
weitere optische Anpassungen vorzunehmen haben wir die CSS-Language-Extension ''less'' verwendet. Mit dieser war es möglich übersichtliche und
einheitliche Style-Vorgaben die Design-Komponenten anzuwenden. 
\\
\\Damit Alle Daten Component-Übergreifend auf einen gemeinsamen Datenstamm zugreifen können und die Daten auch nach einer Session persistent
gespeichert werden können, haben wir die vue.js-Erweiterung ''vuex'' eingesetzt. Diese bietet eine zentralisierte Speichermöglichkeit
für alle Daten, die übergreifend verwendet werden müssen (beispielsweise Log-In Daten oder der Zustand des Variantenfolgegraphen).
\\
\\Für die Darstellung des Graphen (Knoten + Kanten und deren Beschriftung) haben wir das JavaScript Framework ''cytoscape.js'' verwendet.
Das Framework hält alle Graph-Daten in einem JavaScript Objekt, auf das mit verschiedenen API-Funktionen zugegriffen werden kann.
Die Darstellung des Graphen wird über ein Canvas HTML Element realisiert, in welches cytoscape die angelegten Knoten und Kanten zeichnet.
Cytoscape.js bietet ebenfalls eine Hand voll Algorithmen zur analytischen Auswertung des Graphen. Da die Optimierung des Variantenfolgegraphen
allerdings zusätzlicher Bedingungen und Parametern unterliegt, wurde ein eigener Variantenfolgegraph-Optimierungsalgorithmus entwickelt.
\\
\\Bei der Wahl der serverseitigen Architektur haben wir eine REST-Konforme (Representational State Transfer)
Architektur eingesetzt, in dessen Mitte eine MySQL Datenbank zur Speicherung der cytoscape Objekte, sowie Authentifizierungsdaten
steht. Auf die Daten der Datenbank greift eine API-Schnittstelle zu, welche mit Node.js umgesetzt ist (weitere Details zur Schnittstelle:
siehe II.4 - Schnittstellen). Anfragen an die API werden mit dem ''axios'' Framework per ''Promise-based'' HTTP-Requests gestellt. Die HTTP-Requests
folgen einem klaren Schema, welches vom serverseitigen Node.js interpretiert und an die Datenbank weitergeleitet wird.
\\
\\Um die Web-App großflächig zu testen haben wir uns zum einen für das Framework ''cypress'' entschieden, welches Integrationstests anhand der
HTML-Elemente übernimmt. Cypress wertet aus, ob bestimmte Elemente unter bestimmten Bedingungen vorhanden sind, beziehungsweise spezielle 
Eigenschaften aufweisen. Die Cypress Tests haben wir auch erfolgreich an die ''CI / CD Pipeline'' von GitLab angeschlossen, sodass nach jedem
push die Tests durchlaufen (Stichwort: Regressionstest).
\\Zum anderen haben wir das Framework "jest" eingesetzt, mit dem einzelne Funktionen auf ihre Richtigkeit überprüft werden konnten. Vorallem
für die Optimierungsalgorithmen sind isolierte Tests nötig gewesen.
\\
\\Um eine Client-Server Architektur zu simulieren haben wir ''Docker'' eingesetzt. Dieses Tool erlaubt es virtuelle Maschinen zu erstellen,
welche untereinander kommunizieren können. Für Entwicklungszwecke haben wir einen Docker-Container für eine MySQL Datenbank und 
einen Node.js-Webserver (API Schnittstelle) erzeugt.


\subsection{Definierte Schnittstellen}
{\small Autor: Julius Hohlfeld}

VarGs Funktionalitäten erforden eine Datenbank um die erstellten Graphen speichern und wieder abrufen zu können.\\
Um den Zugriff auf die Datenbank zu kontrollieren benötigen wir eine definierte Schnittstelle (bzw. API) zwischen Client,
Webserver und Datenbank.\\
\\
Diese Schnittstelle ist RESTfull - d.h. sie folgt einigen der sog. REST-Constraints. Eine Übersicht inwiefern zu REST und welche
Bedeutung es für das Projekt hat, findet sich im GitLab Wiki unter 'API Dokumentation'.\\
Die Schnittstelle setzt sich wie folgt zusammen:
\begin{itemize}
\item \textbf{Vue}
  \\\textit{Framework für Client + Axios Modul für asnychrone (promise-based) HTTP-Requests}
\item  \textbf{Express}
  \\\textit{Serverseitiges Node-Module für Webserver: hört angemeldete Ports auf Requests ab, die dem URI-Modell entsprechen}
\item \textbf{Node.js}
  \\\textit{Serverseitige Programmierung des Webservers mit mysqljs als Driver, um auf die Datenbank zuzugreifen}
\item \textbf{DB}
  \\\textit{MySQL-Datenbank auf extra Server}
\end{itemize}

Diese Struktur (kurz VenDB) entspricht einer Anpassung des sog. MEAN-Stacks auf das VarG-Projekt (MongoDB, Express, Angular, Node.js).\\
Dabei erfolgt jeglicher Austausch der Graphdaten im JSON Format damit auf die cytoscape.js Funktion zum Laden des Graphen zugegriffen werden kann.\\
\\
\subsubsection{Client}

Der Client enthält Trigger durch Events, welche Requests an den Webserver senden. Z.B.: das Aufrufen des Datenbankfenster löst eine Anfrage aus, welche alle Graphen des aktuellen Nutzers abfragt.
Diese werden durch das Axios-Modul umgesetzt. Nachdem der Trigger ausgelöst wird, schickt der Client eine asynchrone Request. Diese wird vom Webserver verarbeitet, welcher dann eine Antwort schickt. Diese kann von Axios aufgefangen werden (axios."request"(url, {}).then(response => {}).catch(error => {})). 

\subsubsection{Server}

Der durch Express und mysqljs programmierte Webserver definiert folgende mögliche Zugriffstellen auf die Datenbank:
\begin{itemize}
\item \textbf{Get-Requests}
  \begin{itemize}
    \item \textbf{graph}
      \\\textit{Fragt alle Graphen aus der Datenbank ab - für Admin reserviert.}
    \item \textbf{graph/:id?}
      \\\textit{Fragt einen spezifischen Graphen (entsprechend der ID) ab.}
    \item \textbf{graph/meta}
      \\\textit{Fragt Metadaten z.B.: Namen, Id, Stückzahl usw. ab für die Graphen des Nutzers ab.}
  \end{itemize}
\item  \textbf{Put-Requests}
  \begin{itemize}
    \item \textbf{graph/:id?}
      \\\textit{Client schickt Server eine Repräsentation des Graphen in Json um einen bereits existierenden Graphen (entsprechend der ID) zu überschreiben.}
  \end{itemize}
\item \textbf{Post-Requests}
  \begin{itemize}
    \item \textbf{graph?}
      \\\textit{Client schickt Server eine Repräsentation des Graphen in Json um einen neuen Eintrag für den Nutzer zu erzeugen.}
  \end{itemize}
\item \textbf{Delete-Request}
  \begin{itemize}
    \item \textbf{graph/:id?}
      \\\textit{Spezifizierter Graph (entprechend der ID) wird aus der Datenbank gelöscht.}
  \end{itemize}
\end{itemize}

Das '?' bedeutet, dass hier auf bestimmte URL Queries geachetet werden kann.
Das ist nützlich um z.B.: einen Nutzer nur auf seine eigenen Graphen zugreifen zu lassen.
Diese werden dann in die entsprechenden Queries umgewandelt.\\

\subsection{Liste der Architekturentscheidungen}
{\small Autor: xxx}

XXX (bewusste und unbewusste Entscheidungen mit zeitlicher Einordnung)



\section{Prozess- und Implementationsvorgaben}

\subsection{Definition of Done}
{\small Autor: xxx}

XXX

\subsection{Coding Style}
{\small Autor: xxx}

XXX

\subsection{Zu nutzende Werkzeuge}
{\small Autor: xxx}

XXX

\newpage

%%%%%%%%%%%%
%% Abschnitt mit den Sprints beginnt hier
%%%%%%%%%%%%

\section{Sprint 1}

\input{sprint1}

\newpage

\section{Sprint 2}

\input{sprint2}

\newpage

\section{Sprint 3}

%\input{sprint3}

\newpage

\section{Sprint 4}

\input{sprint4}

\newpage

%%%%%% weitere Sprints analog


\section{Dokumentation}

\subsection{Handbuch}
{\small Autor: xxx}

XXX

\subsection{Installationsanleitung}
{\small Autor: xxx}

XXX

\subsection{Software-Lizenz}
{\small Autor: xxx}

XXX


\section{Projektabschluss}

\subsection{Protokoll der Abnahme und Inbetriebnahme beim Kunden}
{\small Autor: xxx}

XXX

\subsection{Präsentation auf der Messe}
{\small Autor: xxx}

Poster, Bericht

\subsection{Abschließende Einschätzung durch Product-Owner}
{\small Autor: xxx}

XXX

\subsection{Abschließende Einschätzung durch Software-Architekt}
{\small Autor: xxx}

XXX

\subsection{Abschließende Einschätzung durch Team-Manager}
{\small Autor: xxx}

XXX

\end{document}
