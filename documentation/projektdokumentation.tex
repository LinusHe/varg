\documentclass[twoside]{report}

% ------
% Umlaute
\usepackage{ifluatex,ifxetex}
\ifluatex
  \usepackage{fontspec}
\else
  \ifxetex
    \usepackage{fontspec}
  \else
    \usepackage{selinput}
    \SelectInputMappings{
      adieresis={ä},
      germandbls={ß},
    }
    \usepackage[T1]{fontenc}
    %\usepackage{textcomp}% optional
    %\usepackage{lmodern}
  \fi
\fi

% ------
% Paper auf Deutsch
\usepackage[ngerman]{babel}



% ------
% Page layout
\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry}
\usepackage[font=it]{caption}
\usepackage{paralist}
%\usepackage{multicol}


% ------
% Abstract
\usepackage{abstract}
	\renewcommand{\abstractnamefont}{\normalfont\bfseries}
	\renewcommand{\abstracttextfont}{\normalfont\small\itshape}


% ------
% Titling (section/subsection)
\usepackage{titlesec}
\renewcommand\thesection{\Roman{section}}
\titleformat{\section}[block]{\Large\scshape\bfseries}{\thesection.}{1em}{}
\setcounter{secnumdepth}{3}

% ------
% Tabellen über Seitenumbrüche hinweg
\usepackage{longtable}

% ------
% Header/footer
\usepackage{fancyhdr}
	\pagestyle{fancy}
	\fancyhead{}
	\fancyfoot{}
	\fancyhead[C]{Projektdokumentation $\bullet$ PROJEKTNAME $\bullet$ SS17$+$WS17/18}
	\fancyfoot[RO,LE]{}


% ------
% Clickable URLs (optional)
% \usepackage{hyperref}

% ------
% Literaturverweise mit Bibtex einbinden
\usepackage[authoryear,sectionbib,round]{natbib}

% ------
% Bilder laden
\usepackage[pdftex]{graphicx}

% ------
% Maketitle metadata
\title{\vspace{-5mm}%
	\fontsize{24pt}{10pt}\selectfont
	\textbf{Projektdokumentation}
	}	
\author{%
        % alle Autoren hier listen
        % 
	\large
	\textsc{Autor I -- E-Mail} \\[2mm]
	\textsc{Autor II -- E-Mail} \\[2mm]
	\normalsize	HTWK Leipzig 
	}
\date{}



%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}


% -------
% Titel und Abstract über beide Spalten
%\twocolumn[
%\begin{@twocolumnfalse}

\maketitle
\thispagestyle{fancy}

\tableofcontents

%%%%
%%%% Die Struktur des Dokuments bitte nicht aendern!!!
%%%%

\section{Anforderungsspezifikation}

\subsection{Initiale Kundenvorgaben}
{\small Autor: xxx}

Maecenas sed ultricies felis. Sed imperdiet dictum arcu a egestas.
In sapien ante, ultricies quis pellentesque ut, fringilla id sem. Proin justo libero, dapibus consequat auctor at, euismod et erat. Sed ut ipsum erat, iaculis vehicula lorem. Cras non dolor id libero blandit ornare. Pellentesque luctus fermentum eros ut posuere. Suspendisse rutrum suscipit massa sit amet molestie. Donec suscipit lacinia diam, eu posuere libero rutrum sed. Nam blandit lorem sit amet dolor vestibulum in lacinia purus varius. Ut tortor massa, rhoncus ut auctor eget, vestibulum ut justo.


\subsection{Produktvision}
{\small Autor: Alex Hofmann}
\\

\noindent Product Vision Board: \\
\begin{tabular}{|p{50mm}|p{50mm}|p{50mm}|}
  \hline
  \textbf{Target Group}                                                  & \textbf{Needs}                                                                                                                        & \textbf{Product}                                                                                                                                                                                                 \\
  \hline
  -Maschinenbau-Studenten \newline Maschinenbau-Profs \newline -Lehrende & Vgl. zu händisch: \newline einheitlicher, schneller \newline -plattformunabhängig \newline -Open Source \newline -Einfach zu bedienen & -Webanwendung \newline -Als Graph \newline $\rightarrow$ quasi als Baukasten \newline $\rightarrow$ Kantengewichtung, Bausteine wählbar \newline -Import/Export von Modellen \newline Normalisierung des Graphen \\
  \hline
\end{tabular}
\\

\noindent Die Webanwendung VarG ist entwickelt für Lehrende und Lernende aus dem Maschinenbau Bachelorstudiengang.
Diese erleichtert die einheitliche Erstellung, Bearbeitung, Optimierung sowie Im- bzw. Exportierung von sogenannten Variantenfolgegraphen. Darunter ist eine graphische Übersicht zu verstehen, die die möglichen Varianten eines Produktionsprozesses für ein Werkstück darstellt.



% Das hier ist ein Absatz, der die Grafik in Abbildung~\ref{fig:bild1} detailliert erläutert, erklärt und interpretiert.

% \begin{figure}[b]
%   \centering
%   \includegraphics[width=4.5cm]{bspbild1.png}
%   \caption{Beispiel für ein einspaltiges Bild}
%   \label{fig:bild1}
% \end{figure}


\subsection{Liste der funktionalen Anforderungen}
{\small Autor: Erik Heldt}

\begin{itemize}
  \item Erstellen von Zuständen mit Namen \& Kürzel
  \item Erstellen von Arbeitsschritten mit Namen \& Kürzel zwischen je 2 Zuständen
  \item Zuweisen von (Rüst-)Zeitkosten, (Rüst-)Geldkosten \& Losgröße zu Arbeitsschritt
  \item Anzeigen des günstigsten Weges im Graph, berechnet nach der angegebenen Kostenart
  \item Lokaler Export als Bilddatei oder importierbarer JSON \& Lokaler Import als JSON
  \item Hochladen in online gehostete Datenbank \& Laden aus online gehosteter Datenbank
  \item Login-Management für Zugriffskontrolle auf Anwendung
  \item Rollen-Management (Student, Professor) für Zugriffsrechte auf Datenbank
\end{itemize}

%
% soll der Inhalt dieser Subsection in einer separaten Datei
% (z.B. listefunktional.tex) liegen, dann kann dies mit dem
% folgenden Kommando geschehen.
%
% \input{listefunktional}

\subsection{Liste der nicht-funktionalen Anforderungen}
{\small Autor: Erik Heldt}

\begin{itemize}
  \item Schnelle Einarbeitung in die Anwendungsumgebung
  \item Einfacher \& intuitiver Umgang mit den Programmkomponenten und -funktionen
  \item Stabiler \& konsistenter Programmablauf, keine Abstürze oder Verluste von Dateien
  \item Kompatibilität mit so vielen modernen Browsern wie möglich
  \item Sicherheit \& korrekte Funktionalität des Login-Algorithmus und des DB-Rollenmanagements
  \item Datenschutz bei Login-Sessions einhalten
\end{itemize}

\subsection{Weitere Zuarbeiten zum Produktvisions-Workshop}
{\small Autor: Erik Heldt}

Für den Produktvisions-Workshop wurden 4 Dokumente erstellt, welche unterschiedliche Aspekte des Anwendungsentwurfs behandeln.

Die erste Ausarbeitung zeigt Ideen zur Darstellung der GUI, die Zweite ist ein Epic bzw. eine Zusammenfassung vieler User-Stories zu allgemeinen Anforderungen an die Funktionalität. Das dritte Dokument geht genauer auf spezifische Kernfunktionen ein und das vierte umfasst die Datenmodellierung des Programms.

\subsubsection{Zuarbeit von Linus Herterich, Jonas Gwozdz, Julius Hohlfeld}
INCLUDE GUI

\subsubsection{Zuarbeit von Erik Heldt, Alaa Aldin Karkoutli}
INCLUDE Epic

\subsubsection{Zuarbeit von Lennart Buchmann, Nils Buxel, Matthias Berger}
INCLUDE Kernfunktionalität

\subsubsection{Zuarbeit von Tim Henning, David Koch}
INCLUDE Datenmodell

\subsection{Liste der Kundengespräche mit Ergebnissen}
{\small Autor: xxx}

XXX



\section{Architektur und Entwurf}

\subsection{Zuarbeiten der Teammitglieder}
{\small Autor: Erik Heldt}

Für die Technologierecherche informierte sich das Team über verschiedene Technologien, mit denen die Anwendung entwickelt werden kann. Außerdem fassten wir erste Ideen zur Graphenanordnung zusammen, legten Coding Conventions fest und erstellten einen interaktiven GUI-Prototyp mit Adobe XD. Die Ausarbeitungen wurden in den nachfolgenden Dokumenten festgehalten.

\subsubsection{Zuarbeit von Tim Henning}
INCLUDE DjangoPython

\subsubsection{Zuarbeit von Erik Heldt}
INCLUDE RailsLang,RailsKurz,Graphenanordnung

\subsubsection{Zuarbeit von David Koch}
INCLUDE JavaCanvas,RechercheDB

\subsubsection{Zuarbeit von Matthias Berger, Nils Buxel}
INCLUDE CodingGuidelines

\subsubsection{Zuarbeit von Nils Buxel}
INCLUDE CodingConventionsCSS

\subsubsection{Zuarbeit von Julius Hohlfeld}
INCLUDE Angular

\subsubsection{Zuarbeit von Lennart Buchmann, Alaa Aldin Karkoutli, Jonas Gwozdz, Linus Herterich}
INCLUDE OpenSource

\subsubsection{Zuarbeit von Linus Herterich, Jonas Gwozdz}
INCLUDE AdobeXD

\subsection{Entscheidungen des Technologieworkshops}
{\small Autor: Erik Heldt}

Nach ausgiebigen Recherchen über verschiedenste Programmiersprachen, Frameworks und Bibliotheken entschieden wir uns für eine Webanwendung auf Basis von HTML/CSS/JavaScript.

Wir haben uns weiterhin auf das JS-Framework Vue.js geeinigt, da es viele Vorteile für die Front-End-Entwicklung mit sich bringt und von den vielen untersuchten Frameworks am intuitivsten erschien. Außerdem haben wir nach einer JS-Bibliothek zur Graphdarstellung recherchiert und unter verschiedenen Kandidaten stach Cytoscape mit seinen vielen Funktionen zur Graphenerstellung und -editierung am meisten heraus, was wir somit auch in unsere Architektur integrierten.

Bei der Programmierumgebung waren wir uns schnell einig, dass Visual Studio Code am besten für unsere Ansprüche geeignet ist. Wir installierten die IDE zusammen mit dem Plugin ESLint zur Unterstützung der Einhaltung standardmäßiger Coding Conventions.

\subsection{Überblick über Architektur}
{\small Autor: Linus Herterich}

VarG ist eine Web-App nach dem Client-Server Modell, wobei der Großteil der Berechnungen per JavaScript auf dem clientseitigen Browser
durchgeführt werden.
\\Serverseitig wird eine Datenbank (inkl API-Schnittstelle) zum persistenten Speichern der erstellten Graphen angeboten.
\\
\\Die Architektur der Web-App basiert auf dem Javascript-Webframework ''Vue.js'',
mit dem Webanwendungen nach dem MVVM Muster (Model View ViewModel) realisiert werden können. Die gesamte App ist nach logischen
Sites (Seiten, bei denen sich die URL ändert) und Components (wiederverwendbare, abgeschlossene Software-Schnipsel) aufgebaut.
Jede Vue Component (.vue Dateien) enthält ein HTML-Template (GUI), sowie Daten, mit denen das Template befüllt wird. Zudem werden
Funktionen definiert, die entweder zu bestimmten Laufzeitbedingungen der App oder durch Events und Trigger aufgerufen werden.
Die Kommunikation zwischen Components wird über Vererbungen zu Eltern-/ Kind-Components realisiert.
\\Die Web-App besteht im Entwicklungszustand aus vielen hunderten Dateien, welche vom Framework verwaltet werden. Sobald
die App in den Produktionsstatus wechselt, muss das Projekt kompiliert werden. Dies übernimmt ebenfalls das Framework, welches
hierfür Technologien wie ''WebPack'' einsetzt. So bleiben lediglich wenige HTML, CSS und JavaScript Dateien übrig, die anschließend
auf einem Web-Server (z.B. Apache) zur Verfügung gestellt werden müssen.
\\
\\Um die Darstellung einheitlich zu halten, haben wir die UI-Bibliothek ''vuetify'' genutzt. Diese hält sich an den Industriestandard
''Material Design'' von Google. Damit konnten wir alle unsere im Vorfeld erstellten Design-Konzepte umsetzen. Um an den ''vuetify'' Elementen
weitere optische Anpassungen vorzunehmen haben wir die CSS-Language-Extension ''less'' verwendet. Mit dieser war es möglich übersichtliche und
einheitliche Style-Vorgaben die Design-Komponenten anzuwenden.
\\
\\Damit Alle Daten Component-Übergreifend auf einen gemeinsamen Datenstamm zugreifen können und die Daten auch nach einer Session persistent
gespeichert werden können, haben wir die vue.js-Erweiterung ''vuex'' eingesetzt. Diese bietet eine zentralisierte Speichermöglichkeit
für alle Daten, die übergreifend verwendet werden müssen (beispielsweise Log-In Daten oder der Zustand des Variantenfolgegraphen).
\\
\\Für die Darstellung des Graphen (Knoten + Kanten und deren Beschriftung) haben wir das JavaScript Framework ''cytoscape.js'' verwendet.
Das Framework hält alle Graph-Daten in einem JavaScript Objekt, auf das mit verschiedenen API-Funktionen zugegriffen werden kann.
Die Darstellung des Graphen wird über ein Canvas HTML Element realisiert, in welches cytoscape die angelegten Knoten und Kanten zeichnet.
Cytoscape.js bietet ebenfalls eine Hand voll Algorithmen zur analytischen Auswertung des Graphen. Da die Optimierung des Variantenfolgegraphen
allerdings zusätzlicher Bedingungen und Parametern unterliegt, wurde ein eigener Variantenfolgegraph-Optimierungsalgorithmus entwickelt.
\\
\\Bei der Wahl der serverseitigen Architektur haben wir eine REST-Konforme (Representational State Transfer)
Architektur eingesetzt, in dessen Mitte eine MySQL Datenbank zur Speicherung der cytoscape Objekte, sowie Authentifizierungsdaten
steht. Auf die Daten der Datenbank greift eine API-Schnittstelle zu, welche mit Node.js umgesetzt ist (weitere Details zur Schnittstelle:
siehe II.4 - Schnittstellen). Anfragen an die API werden mit dem ''axios'' Framework per ''Promise-based'' HTTP-Requests gestellt. Die HTTP-Requests
folgen einem klaren Schema, welches vom serverseitigen Node.js interpretiert und an die Datenbank weitergeleitet wird.
\\
\\Um die Web-App großflächig zu testen haben wir uns zum einen für das Framework ''cypress'' entschieden, welches Integrationstests anhand der
HTML-Elemente übernimmt. Cypress wertet aus, ob bestimmte Elemente unter bestimmten Bedingungen vorhanden sind, beziehungsweise spezielle
Eigenschaften aufweisen. Die Cypress Tests haben wir auch erfolgreich an die ''CI / CD Pipeline'' von GitLab angeschlossen, sodass nach jedem
push die Tests durchlaufen (Stichwort: Regressionstest).
\\Zum anderen haben wir das Framework "jest" eingesetzt, mit dem einzelne Funktionen auf ihre Richtigkeit überprüft werden konnten. Vorallem
für die Optimierungsalgorithmen sind isolierte Tests nötig gewesen.
\\
\\Um eine Client-Server Architektur zu simulieren haben wir ''Docker'' eingesetzt. Dieses Tool erlaubt es virtuelle Maschinen zu erstellen,
welche untereinander kommunizieren können. Für Entwicklungszwecke haben wir einen Docker-Container für eine MySQL Datenbank und
einen Node.js-Webserver (API Schnittstelle) erzeugt. Ein weiterer Docker-Container wurde eingesetzt, auf dem ''Adminer'' lief. Mit diesem
Tool ist es möglich die MySQL-Datenbank komfortabel und umfangreich anzupassen.


\subsection{Definierte Schnittstellen}
{\small Autor: Julius Hohlfeld}

VarGs Funktionalitäten erforden eine Datenbank um die erstellten Graphen speichern und wieder abrufen zu können.\\
Um den Zugriff auf die Datenbank zu kontrollieren benötigen wir eine definierte Schnittstelle (bzw. API) zwischen Client,
Webserver und Datenbank.\\
\\
Diese Schnittstelle ist RESTfull - d.h. sie folgt einigen der sog. REST-Constraints. Eine Übersicht inwiefern zu REST und welche
Bedeutung es für das Projekt hat, findet sich im GitLab Wiki unter 'API Dokumentation'.\\
Die Schnittstelle setzt sich wie folgt zusammen:
\begin{itemize}
  \item \textbf{Vue}
        \\\textit{Framework für Client + Axios Modul für asnychrone (promise-based) HTTP-Requests}
  \item  \textbf{Express}
        \\\textit{Serverseitiges Node-Module für Webserver: hört angemeldete Ports auf Requests ab, die dem URI-Modell entsprechen}
  \item \textbf{Node.js}
        \\\textit{Serverseitige Programmierung des Webservers mit mysqljs als Driver, um auf die Datenbank zuzugreifen}
  \item \textbf{DB}
        \\\textit{MySQL-Datenbank auf extra Server}
\end{itemize}

Diese Struktur (kurz VenDB) entspricht einer Anpassung des sog. MEAN-Stacks auf das VarG-Projekt (MongoDB, Express, Angular, Node.js).\\
Dabei erfolgt jeglicher Austausch der Graphdaten im JSON Format damit auf die cytoscape.js Funktion zum Laden des Graphen zugegriffen werden kann.\\
\\
\subsubsection{Client}

Der Client enthält Trigger durch Events, welche Requests an den Webserver senden. Z.B.: das Aufrufen des Datenbankfenster löst eine Anfrage aus, welche alle Graphen des aktuellen Nutzers abfragt.
Diese werden durch das Axios-Modul umgesetzt. Nachdem der Trigger ausgelöst wird, schickt der Client eine asynchrone Request. Diese wird vom Webserver verarbeitet, welcher dann eine Antwort schickt. Diese kann von Axios aufgefangen werden (axios."request"(url, {}).then(response => {}).catch(error => {})).

\subsubsection{Server}

Der durch Express und mysqljs programmierte Webserver definiert folgende mögliche Zugriffstellen auf die Datenbank:
\begin{itemize}
  \item \textbf{Get-Requests}
        \begin{itemize}
          \item \textbf{graph}
                \\\textit{Fragt alle Graphen aus der Datenbank ab - für Admin reserviert.}
          \item \textbf{graph/:id?}
                \\\textit{Fragt einen spezifischen Graphen (entsprechend der ID) ab.}
          \item \textbf{graph/meta}
                \\\textit{Fragt Metadaten z.B.: Namen, Id, Stückzahl usw. ab für die Graphen des Nutzers ab.}
        \end{itemize}
  \item  \textbf{Put-Requests}
        \begin{itemize}
          \item \textbf{graph/:id?}
                \\\textit{Client schickt Server eine Repräsentation des Graphen in Json um einen bereits existierenden Graphen (entsprechend der ID) zu überschreiben.}
        \end{itemize}
  \item \textbf{Post-Requests}
        \begin{itemize}
          \item \textbf{graph?}
                \\\textit{Client schickt Server eine Repräsentation des Graphen in Json um einen neuen Eintrag für den Nutzer zu erzeugen.}
        \end{itemize}
  \item \textbf{Delete-Request}
        \begin{itemize}
          \item \textbf{graph/:id?}
                \\\textit{Spezifizierter Graph (entprechend der ID) wird aus der Datenbank gelöscht.}
        \end{itemize}
\end{itemize}

Das '?' bedeutet, dass hier auf bestimmte URL Queries geachetet werden kann.
Das ist nützlich um z.B.: einen Nutzer nur auf seine eigenen Graphen zugreifen zu lassen.
Diese werden dann in die entsprechenden Queries umgewandelt.\\

\subsection{Liste der Architekturentscheidungen}
{\small Autor: xxx}

XXX (bewusste und unbewusste Entscheidungen mit zeitlicher Einordnung)



\section{Prozess- und Implementationsvorgaben}

\subsection{Definition of Done}
{\small Autor: Tim Henning}
\\
Im Allgemeinen wurde in dem Projekt die Definition von "doneness"\ nicht all zu umfangreich
gestaltet, da es für viele Teammitglieder eines der ersten Softwareprojekte war. So wurden als Defintion of Done folgende
Punkte für alle Userstories aufgestellt:
\begin{itemize}
  \item >50\% Testabdeckung
  \item Technische Kommentare im Code
  \item Einhaltung der festgelegten Code Konventionen
\end{itemize}
Das Team hatte an sich zu den meisten Zeitpunkten eine klare Vorstellung was einen "fertigen Entwurf"\ kennzeichnet und wurde so auch in den Reviews untereinander kommuniziert.
Dies wiederum führte zu einer klaren Transparenz im Team, was die Qualität des Produktes erhöhte und das Zusammenarbeiten erleichterte.
Größtenteils wurde sich
an die allgemeinen Akzeptanzkritieren gehalten und viele Backlog-Einträge als "done"\ erklärt. Zu fast jeder Komponente wurde
getestet und zu den Methoden der einzelnen Komponenten wurden erklärende sinnvolle Codekommentare geschrieben.
Außerdem wurde im Team umfangreich kommuniziert und die Kriterien angepasst, wenn die Fertigstellung einer Userstorie doch mal nicht gänzlich klar war.
So wurde es ermöglicht nach der Hälfte des Projektes, am Ende jedes Sprints einen fertigen Productionbuild dem Kunden zu liefern.



\subsection{Coding Style}
{\small Autor: xxx}

XXX

\subsection{Zu nutzende Werkzeuge}
{\small Autor: Linus Herterich}

Im folgenden werden die Werkzeuge erwähnt, mit denen wir die Software
entwickelt haben. Zudem wird darauf eingegangen, über welche Kanäle kommuniziert
wurde.


\subsubsection{Voraussetzungen}
Das Versionsmanagement-Tool ''GitLab'' sowie das Zeitmanagement-Tool ''YouTrack''
wurde zu Beginn des Projekts vorgeschrieben. Die Commits in ''GitLab'' werden jeweils mit
der ID des zugehörigen YouTrack-Tickets am Anfang des Commit-Titels versehen.
\\Damit das gesamte Team einheitliche Versionen der verwendeten Bibliotheken benutzt,
wird der Paketmanager ''npm'' verwendet. Mir diesem lassen sich Pakete (und deren Versionen) definieren,
welche für das Projekt benötigt werden.
\\ Damit am Projekt gearbeitet werden kann, muss sich somit jedes Teammitglied die LTS-
Version von Node.js (welches npm enthält) installieren.
\\ Sobald Node.js global installiert ist, kann im ''code'' Verzeichnis der Befehl
''npm install'' ausgeführt werden, um die benötigten Bibliothekten zu installieren.

\subsubsection{Compiler}
Achtung: Das Kompileren funktioniert erst, sobald die Bibliothekten mit dem Befehl
''npm install'' (im /code Verzeichnis) installiert wurden
\\
Um Änderungen des Projektes einzusehen, muss das Projekt kompiliert werden.
''Vue.js'' bringt bereits einen Echtzeit-Compiler mit, welcher reagiert, sobald Änderungen
an Dateien im ''code'' Verzeichnis gemacht wurden. Um diesen Compiler aufzurufen, muss der npm-Befehl ''npm run serve'' im ''code'' Verzeichnis
aufgerufen werden.
\\Um das Projekt nicht während der Entwicklung zu kompilieren, sondern für die Produktion freizugeben,
muss der Befehl ''npm run build'' im ''code'' Verzeichnis aufgerufen werden. Es werden
anschließend die kompilierten Dateien im Verzeichnis ''code/dist'' abgelegt.
Diese können anschließend auf einem Webserver (z.B. Apache HTTP Server) hochgeladen werden.

\subsubsection{Entwicklungsumgebung}
Für die Entwicklung der Software wird der freie Quelltext-Editor ''Visual Studio Code''
von Microsoft verwendet. Dieser ist plattformunabhängig und kann durh zahlreiche Erweiterungen
angepasst werden. Beispielsweise kann durch ein Plugin die ''Vue.js''-eigene Syntax
vervollständigt und hervorgehoben werden.
\\Weitere Einstellungsvorgaben bezüglich der Entwicklungsumgebung wurden nicht getroffen.
Es muss allerdings darauf geachtet werden, dass die Coding-Conventions durch automatische
Formatierungen eingehalten werden.

\subsubsection{CI / CD Pipeline}
In der CI / CD Pipeline unseres Versionsmanagement-Tools, die nach jedem Git-Push
ausgeführt wird, werden folgende Operationen durchgeführt:
\begin{itemize}
  \item Test, ob das Projekt kompiliert (inklusive Syntaxprüfung durch ES-Lint)
  \item Cypress Tests durchführen (siehe ''Überblick über Architektur'')
  \item LaTEX Doku kompilieren
\end{itemize}

Sollte einer der Punkte fehlschlagen, wird der Autor des Git-Push's per E-Mail
darüber informiert. Somit ist die wahrscheinlichkeit, dass bestehende Features durch
neue Entwicklungen längerfristig ''zerstört'' werden, möglichst gering.

\subsubsection{Docker}
Um die Client-Server Architektur des Projektes lokal zu simulieren, wird die
Container-Virtualisierungssoftware ''Docker'' verwendet.
Mit dieser haben wir einen Webserver simuliert, auf dem die Datenbank ausgeführt
und verwaltet wird (siehe ''Überblick über Architektur''). Die Container werden
im Projekt-Ordner ''docker'' definiert.


\subsubsection{Kommunikationstools}
Zu Beginn des Projekts wurde sich auf das kostenlose Kommunikationstool ''Slack'' geeinigt.
Mit diesem ist es möglich in verschiedenen Kanälen Text, Dateien und Medien auszutauschen.
Auch private Konversationen, sowie Kleingruppen-Chaträume sind in diesem Tool möglich.
Die Software kann sowohl als App installiert werden, als auch im Browser verwendet werden.
\\Da wir über die Weihnachtsferien einen Sprint durchgeführt haben, führten wir Mitte Dezember
das Tool ''Discord'' ein, mit dem es möglich ist sich in Echtzeit-Sprachchats zusammenzufinden.
Dazu ist es es möglich seinen Desktop zu teilen, womit sich das Tool bestens geeignet hat,
um räumlich getrennt über Code-Passagen oder neue Features zu sprechen.
\\Die Kombination beider Tools hat problemlos funktioniert und uns auch
während des Lockdowns in der ''Corona-Krise'' geholfen. Da wir die Tools bereits frühzeitig
eingesetzt haben, war kaum eine Um- bzw. Eingewöhnungszeit zu Beginn der
präsenzfreien Zeit notwendig.


\newpage

%%%%%%%%%%%%
%% Abschnitt mit den Sprints beginnt hier
%%%%%%%%%%%%

\section{Sprint 1}

\input{sprint1}

\newpage

\section{Sprint 2}

\input{sprint2}

\newpage

\section{Sprint 3}

%\input{sprint3}

\newpage

\section{Sprint 4}

\input{sprint4}

\newpage

%%%%%% weitere Sprints analog


\section{Dokumentation}

\subsection{Handbuch}
{\small Autor: xxx}

XXX

\subsection{Installationsanleitung}
{\small Autor: Erik Heldt}

VarG ist eine plattformunabhängige Webanwendung, das heißt man muss nichts lokal auf seinem PC installieren, um sie zu benutzen. Alles was man benötigt, ist ein moderner Web-Browser und eine Internetverbindung (Browser-Empfehlung: Google Chrome oder Firefox). Öffne den Browser und gib in der URL-Leiste www.TODO-sampledomain.de ein. Nun befindest du dich im Home-Menü von VarG und kannst loslegen!

TODO: Installation der Datenbank dokumentieren sobald diese auf den HTWK-Server umgezogen ist.

\subsection{Software-Lizenz}
{\small Autor: xxx}

XXX


\section{Projektabschluss}

\subsection{Protokoll der Abnahme und Inbetriebnahme beim Kunden}
{\small Autor: xxx}

XXX

\subsection{Präsentation auf der Messe}
{\small Autor: xxx}

Poster, Bericht

\subsection{Abschließende Einschätzung durch Product-Owner}
{\small Autor: xxx}

XXX

\subsection{Abschließende Einschätzung durch Software-Architekt}
{\small Autor: xxx}

XXX

\subsection{Abschließende Einschätzung durch Team-Manager}
{\small Autor: xxx}

XXX

\end{document}
